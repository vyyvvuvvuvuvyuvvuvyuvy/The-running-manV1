<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Enhanced Pixel Art Runner with Particles & Background</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  body {
    margin: 0; padding: 0;
    background: #222;
    display: flex; justify-content: center; align-items: center;
    height: 100vh;
    font-family: 'Press Start 2P', monospace;
  }
  #gameContainer {
    position: relative;
    border: 4px solid #fff;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0,0,0,0.7);
  }
  canvas {
    display: block;
    background: #000;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="400"></canvas>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState='menu';

let score=0;
let highScore=localStorage.getItem('pixelHighScore') || 0;
let coins= parseInt(localStorage.getItem('pixelCoins')) || 0;
let lives=3;

// Background layers for parallax
const bgLayers = [
  {speed: 0.2, x:0, color:'#0a0'},
  {speed: 0.4, x:0, color:'#222'},
  {speed: 0.6, x:0, color:'#444'}
];

// Sprite frames for character animation
const spriteFrames=[
  [
    [0,0,1,0,0],
    [0,1,1,1,0],
    [1,1,1,1,1],
    [0,1,0,1,0],
    [1,0,1,0,1]
  ],
  [
    [0,0,1,0,0],
    [0,1,1,1,0],
    [1,1,1,1,1],
    [1,0,0,0,1],
    [0,1,1,1,0]
  ],
  [
    [0,0,1,0,0],
    [0,1,1,1,0],
    [1,1,1,1,1],
    [0,0,1,0,0],
    [0,1,0,1,0]
  ]
];

let spriteFrameIndex=0;
let spriteFrameTimer=0;

// Player object
const player={
  x:100,
  y:0,
  width:12,
  height:12,
  velocityY:0,
  onGround:false,
  jumpPower:-10,
  jumpCount:0,
  maxJumps:2,
  pixelData: spriteFrames[0]
};

// Arrays for game objects
let obstacles=[], coins=[], goblins=[], particles=[];

// Utility: draw pixel art sprite
function drawPixelArt(pixels,x,y,size=4,color='lime') {
  ctx.fillStyle=color;
  for (let r=0; r<pixels.length; r++) {
    for (let c=0; c<pixels[r].length; c++) {
      if (pixels[r][c]) {
        ctx.fillRect(x + c*size, y + r*size, size, size);
      }
    }
  }
}

// Draw animated sprite
function drawPlayer() {
  if (spriteFrameTimer>8) {
    spriteFrameIndex=(spriteFrameIndex+1)%spriteFrames.length;
    spriteFrameTimer=0;
  } else {
    spriteFrameTimer++;
  }
  player.pixelData=spriteFrames[spriteFrameIndex];
  drawPixelArt(player.pixelData, player.x, player.y, 4, 'lime');
}

// Draw layered background for parallax
function drawBackground() {
  for (const layer of bgLayers) {
    ctx.fillStyle=layer.color;
    ctx.fillRect(-layer.x,0,canvas.width+layer.x,canvas.height);
    layer.x+=layer.speed;
    if (layer.x>canvas.width) layer.x=0;
  }
  // Optional: add stars/cloud particles as dots
}

// Draw ground
function drawGround() {
  ctx.fillStyle='darkgreen';
  ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
}

// Draw hearts (lives)
function drawHearts() {
  for(let i=0;i<lives;i++) drawHeart(10 + i*20,10);
}
function drawHeart(x,y) {
  ctx.fillStyle='red';
  ctx.beginPath();
  ctx.moveTo(x+4,y+2);
  ctx.bezierCurveTo(x+4,y,x,y,x,y+4);
  ctx.bezierCurveTo(x,y+8,x+4,y+10,x+8,y+8);
  ctx.bezierCurveTo(x+12,y+10,x+16,y+8,x+16,y+4);
  ctx.bezierCurveTo(x+16,y,x+12,y+2,x+8,y+4);
  ctx.bezierCurveTo(x+4,y+2,x,y,x+4,y+2);
  ctx.fill();
}

// Draw coins with spinning animation
function drawCoins() {
  coins.forEach(c => {
    ctx.save();
    ctx.translate(c.x + c.size, c.y + c.size);
    ctx.rotate(c.angle);
    ctx.fillStyle='gold';
    ctx.beginPath();
    ctx.arc(0,0,c.size,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });
}

// Draw goblin enemies
function drawGoblins() {
  ctx.fillStyle='green';
  goblins.forEach(g => {
    ctx.fillRect(g.x,g.y,g.width,g.height);
  });
}

// Draw particles
function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha=p.alpha;
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x,p.y,p.size,p.size);
  });
  ctx.globalAlpha=1;
}

// Draw all game elements
function draw() {
  drawBackground();
  drawGround();
  drawPlayer();
  obstacles.forEach(o=> ctx.fillStyle='brown', ctx.fillRect(o.x,o.y,o.width,o.height));
  drawCoins();
  drawGoblins();
  drawParticles();
  drawHearts();
  drawScore();

  // Overlay messages
  ctx.font='20px "Press Start 2P"';
  ctx.fillStyle='white';
  if (gameState==='menu') ctx.fillText('CLICK TO START', 300,200);
  if (gameState==='gameOver') {
    ctx.fillText('GAME OVER', 340,180);
    ctx.fillText(`Score: ${score}`, 340,220);
  }
}

// Update game state
function update() {
  if (gameState==='playing') {
    // Animate sprite
    if (spriteFrameTimer>8) {
      spriteFrameIndex=(spriteFrameIndex+1)%spriteFrames.length;
      spriteFrameTimer=0;
    } else {
      spriteFrameTimer++;
    }
    player.pixelData=spriteFrames[spriteFrameIndex];

    // Gravity physics
    player.velocityY+=0.4;
    player.y+=player.velocityY;
    if (player.y+player.height>groundY) {
      player.y=groundY-player.height;
      player.velocityY=0;
    }

    // Parallax background
    for (const layer of bgLayers) {
      layer.x+=layer.speed;
      if (layer.x>canvas.width) layer.x=0;
    }

    // Spawn obstacles, coins, enemies
    if (Math.random()<0.02) obstacles.push({x:canvas.width,y:groundY-10,w:10,h:10});
    if (Math.random()<0.015) coins.push({x:Math.random()*canvas.width,y:groundY-20-Math.random()*50,size:4,angle:0});
    if (Math.random()<0.01) goblins.push({x:canvas.width,y:groundY-12,w:12,h:12,speed:gameSpeed+0.5});

    // Move
    obstacles.forEach(o=> o.x-=gameSpeed);
    coins.forEach(c=> c.x-=gameSpeed);
    goblins.forEach(g=> g.x-=g.speed);

    // Remove off-screen
    obstacles=obstacles.filter(o=>o.x+o.w>0);
    coins=coins.filter(c=>c.x+4>0);
    goblins=goblins.filter(g=>g.x+g.w>0);

    // Collisions
    obstacles.forEach(o=> { if (rectIntersect(player,o)) { loseLife(); createParticles(player.x+player.width/2, player.y+player.height/2, 'red'); } });
    coins.forEach(c=> { if (rectIntersect(player,c)) { c.x=-100; coins++; coinsThisRun++; createParticles(c.x,c.y,'yellow'); } });
    goblins.forEach(g=> { if (rectIntersect(player,g)) { loseLife(); createParticles(player.x+player.width/2, player.y+player.height/2, 'orange'); } });
  }
}

// Particle emitter
function createParticles(x,y,color) {
  for (let i=0; i<8; i++) {
    particles.push({
      x:x + (Math.random()-0.5)*4,
      y:y + (Math.random()-0.5)*4,
      size: Math.random()*2+1,
      alpha:1,
      vx:(Math.random()-0.5)*2,
      vy:-Math.random()*2,
      color:color,
      life:30
    });
  }
}

// Draw score
function drawScore() {
  ctx.font='14px "Press Start 2P"';
  ctx.fillStyle='white';
  ctx.fillText(`SCORE: ${score}`,10,20);
  ctx.fillText(`HI: ${highScore}`,10,40);
  ctx.fillText(`COINS: ${coins}`,10,60);
}

// Input handlers
canvas.onclick= ()=> {
  if (gameState==='menu') startGame();
  else if (gameState==='gameOver') startGame();
  else if (gameState==='playing') jump();
}
document.addEventListener('keydown', e=> {
  if (e.code==='Space') jump();
});

// Jump
function jump() {
  if (player.onGround || (lives>0 && player.jumpCount<player.maxJumps)) {
    player.velocityY=-10;
    player.jumpCount++;
    createParticles(player.x+player.width/2, player.y+player.height, 'white');
  }
}

// Game over
function loseLife() {
  lives--;
  createParticles(player.x+player.width/2, player.y+player.height/2, 'red');
  if (lives<=0) endGame();
}
function resetPlayer() {
  player.x=100; player.y=groundY-player.height; player.velocityY=0; player.jumpCount=0;
}
function startGame() {
  score=0; coinsThisRun=0; lives=3; resetHearts();
  obstacles=[]; coins=[]; goblins=[]; particles=[];
  gameSpeed=2;
  gameState='playing';
  resetPlayer();
}
function endGame() {
  gameState='gameOver';
  if (score>highScore) {
    localStorage.setItem('pixelHighScore',score);
    highScore=score;
  }
}

// Draw hearts
function resetHearts() {
  lives=3;
}
function drawHearts() {
  for(let i=0;i<lives;i++) drawHeart(10 + i*20,10);
}
function drawHeart(x,y) {
  ctx.fillStyle='red';
  ctx.beginPath();
  ctx.moveTo(x+4,y+2);
  ctx.bezierCurveTo(x+4,y,x,y,x,y+4);
  ctx.bezierCurveTo(x,y+8,x+4,y+10,x+8,y+8);
  ctx.bezierCurveTo(x+12,y+10,x+16,y+8,x+16,y+4);
  ctx.bezierCurveTo(x+16,y,x+12,y+2,x+8,y+4);
  ctx.bezierCurveTo(x+4,y+2,x,y,x+4,y+2);
  ctx.fill();
}

// Main loop
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}
gameLoop();

</script>
</body>
</html>
